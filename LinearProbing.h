#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
#include <iterator>
#include <fstream>
#include "Symbol.h"

using namespace std;

int nextPrime( int n ); //declaration of fucntion to find the next prime number
bool isPrime( int n ); //declaration of function to test if number passed in is a prime
size_t hasher(const string & key); //hash function declaration which is being taken from Driver.cpp

//declaring a template for hash
//this one specifically for strings
template<typename string>
class thehash2
{
public:
	//Hash function declaration
    size_t operator()(const string & key)
    {
        size_t hashVal = 0;
        for(char ch : key) // new c++ 11 feature; iterates through the range
            hashVal = 37 * hashVal + ch; //makes the value for hashVal
        return hashVal;
    }
};

//declaring a template for hash
//this one specifically for Symbols
template<typename Symbol>
class thehash
{
public:

	//takes an object of the symbol class
	//to be hased by the template declared above
    size_t operator()(const Symbol & item)
    {
        static thehash2<string> hf; //creates the hash object
        return hf(item.getData()); //takes the data hashed for item via a accessor function
    }
};

//template that allows the Object to be passed in from the Driver.cpp
template<typename HashedObj>
class HashTable
{
public:

	//constructor function for the hash table, using the TABLE_SIZE
	explicit HashTable(int TABLE_SIZE)
	{
		currentSize = 0;
		array.resize(TABLE_SIZE);
	}
	void makeEmpty() //empites out the hash table
	{
		currentSize = 0;
		for(int i = 0; i < array.size(); i++)
		{
			array[i].info = EMPTY;
		}
	}
	//function to search for a specific hashed object in the table 
	//and returns either true or false depending on whether or not 
	//it was found
	bool contains(const HashedObj & x) const
	{
		return isActive(findPos(x)); //returns either true or false
	}

	//function to inserted the hashed object into the table
	bool insert(const HashedObj & x)
	{
		//sets the current position to whatever the hash
		//value is that is generated by findPos(x)
		int positionCurrent = findPos(x);

		//the value of the vector at that particular hash is equal to HashEntry(x, ACTIVE)
		//where ACTIVE equals 1
		array[positionCurrent] = HashEntry(x, ACTIVE);

		//just to cout the current index; becuase why not!
		cout << "Putting in " << x.getData() << " at index " << positionCurrent << endl;

		//if the current table size is greater than the size of the vector,
		//then rehash
		if(++currentSize > array.size())
		{
			rehash();
		}
			
		return true;
	}

	//function to remove a hashed object from the table
	bool remove(const HashedObj & x)
	{
		//sets the current position to whatever the hash
		//value is that is generated by findPos(x)
		int positionCurrent = findPos(x);

		//Refer to the isActive function
		if(!isActive(positionCurrent))
		{
			return false;
		}
			
		array[positionCurrent].entryInfo = DELETED;
		return true;
	}

	//function to print out the hash table
	void print()
	{
		for (int i = 0; i < array.size(); i++)
		{
			cout << "Current index " << i << ":  ";
			cout << " " << endl;
			
			//if i is active, prints out the Symbol objects from the hash table
			if (isActive(i)) 
			{
				cout << array[i] << endl;
			} 
			
			//otherwise, it says empty 
			else
			{
				cout << "empty" << endl; 
			}
		}
			
	}

	//sets ACTIVE to 1, EMPTY to 0, and DELETED to -1
	enum EntryType{ACTIVE, EMPTY, DELETED };
	
	
private:
	
	//Hash entry struct to take care of all hashed objects read it
	struct HashEntry
	{
		HashedObj object; //whatever comes in as HashedObj equal to object
		EntryType entryInfo; //object of EntryType

		//constructor for HashedEntry object
		HashEntry(const HashedObj & e = HashedObj(), EntryType i = EMPTY) : object(e), entryInfo(i) {}

		//overloaded function for "<<" operator for printing out HashedEntry
		friend ostream & operator <<(ostream & outstream, HashEntry & hashentry) //overloaded to print out the the HashTable
		{
			HashedObj Element = hashentry.object;  
			EntryType Info = hashentry.entryInfo;
			outstream << Element << endl; 
			outstream << " " << endl;
			//outstream << Info << endl; 
			return outstream;
		}
	};

	//Declares vector called array of Hash Entries
	vector<HashEntry> array;
	int currentSize;

	bool isActive(int positionCurrent) const
	{
		return array[positionCurrent].entryInfo == ACTIVE;
	}
	
	//function to find the current position
	int findPos(const HashedObj & x) const
	{
		int offset = 1;
		int positionCurrent = myhash(x);

		//to check for collisions
		if(array[positionCurrent].entryInfo != EMPTY)
		{
			cout << "There was a collision at index " << positionCurrent << endl;
		}
		while(array[positionCurrent].entryInfo != EMPTY)
		{
			positionCurrent++;
			if(positionCurrent >= array.size())
			{
				positionCurrent -= array.size();
			}
		}
		return positionCurrent;
	}
	
	//function to rehash the values 
	void rehash()
	{
		cout << "REHASHING" << endl;

		//sets vector arrayOld equal to array to make the new vector
		vector<HashEntry> arrayOld = array;

		//resizes the table according to the old array
		array.resize(nextPrime(2*arrayOld.size()));

		//loops through the array and empties it
		for(int x = 0; x < array.size(); x++)
		{
			array[x].entryInfo = EMPTY;
		}
			

		currentSize = 0;

		//loops through the old array to check to see if its elements are active
		//if they are, inserts the elements
		for(int j = 0; j< arrayOld.size(); j++)
		{	
			if(arrayOld[j].entryInfo == ACTIVE)
			{
				insert(arrayOld[j].object);	
			}	
		}
			
	}

	//takes in an object, and puts the object through the 
	//hash table definition as declared above,
	//and makes a hashed object named hf
	int myhash(const HashedObj & x) const
	{
		static thehash<HashedObj> hf;

		//mods hf by the table size in order
		//to get the appropriate hash value
        return hf( x ) % array.size( );
	}
};


//Function used to search for the next prime number
int nextPrime( int n )
{
    if( n % 2 == 0 )
    {
        ++n;
    }
        

    for( ; !isPrime( n ); n += 2 )
    {

    }
        

    return n;
}


//function to verify that a number is indeed prime
bool isPrime( int n )
{
    if( n == 2 || n == 3 )
        return true;

    if( n == 1 || n % 2 == 0 )
        return false;

    for( int i = 3; i * i <= n; i += 2 )
        if( n % i == 0 )
            return false;

    return true;
}
